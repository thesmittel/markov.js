import * as fs from 'node:fs';
// FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK 
function randomProperty(data) {
    let keys = Object.keys(data);
    let rdm = Math.floor(Math.random() * keys.length);
    return keys[rdm];
}

function getNext(data, text, maxDepth) {
    let depth = maxDepth;
    let following = undefined;
    let total = 0;
    let check = "";
    if (data.model.wordbased) {
        while (data.model.w[check] == undefined) {
            if (depth == 0) return null;
            let arr = text.split(" ")
            let tmp = arr.splice(0, arr.length - depth);
            check = arr.join(" ")
            depth--;
        }
        following = data.model.w[check].f;
        total = data.model.w[check].t;
    } else {
        while (data.model.w[check] == undefined) {
            if (depth == 0) return null;
            check = text.slice(-depth)
            depth--;
        }
        following = data.model.w[check].f;
        total = data.model.w[check].t;
    }

    let cumulative = 0;
    let rdm = Math.random() * total;
    let result = "";

    for (let x in following) {
        following[x] = (following[x] + cumulative);
        cumulative += following[x];
        if (cumulative >= total) {
            result = x;
            break;
        }
    }



    return result;
}

function saveWordBased(filepath, markov) {
    console.log(markov.dict)
    let file = [1, 16];
    let target = 29;

    const stream = fs.createWriteStream(filepath);

    const encoder = new TextEncoder();
    let list =  Array.from(new Set(markov.dict.map(a => a.split(" ")).flat()))
    let dict = list.map(a => [2, ...encoder.encode(a), 3, 0]).flat();
    
    file.push(...dict, 0, 17)
    file.push(17); // Start of metadata;

    if (markov.description != "") {
        file.push(20, 2, ...encoder.encode(markov.description), 3, 0)
    }
    if (markov.license != "") {
        file.push(21, 2, ...encoder.encode(markov.license), 3, 0)
    }
    if (markov.author != "") {
        file.push(22, 2, ...encoder.encode(markov.author), 3, 0)
    }
    if (markov.year > 0) {
        file.push(23, 2, ...getYearWord(markov.year), 3, 0)
    }
    file.push(0)
    file.push(18)
    // Dictionary added
    for (let w in markov.model.w) {
        // index datapoint name
        let indices = w.split(" ")
            .map(a => [
                intToByteArray(list.indexOf(a)+1).length,
                intToByteArray(list.indexOf(a)+1)].flat()) //[length, bytes]
            .flat(); 
        file.push(...[2, ...indices, 3, 0]) // Indices with separators
        file.push(...[intToByteArray(markov.model.w[w].t)].flat()) // Totals
        file.push(0) // Begin of following
        for (let f in markov.model.w[w].f) {
            let index = [intToByteArray(list.indexOf(f)+1)].flat();
            let fdp = [2, ...index, 3, ...[intToByteArray(markov.model.w[w].f[f])].flat(), 0]
            file.push(...fdp)
        }
        file.push(0) // Datapoint separator
    }
    file.push(0); // End of main section
    file.push(4)

    let buffer = new Buffer.from(file);

    stream.write(buffer)
    stream.end()
    
    
}

function loadWordBased(buffer, markov) {
    let sections = [[],[],[]]
    let lastbytes = [-1,-1,-1]

    // Split buffer into parts
    const mainTarget = [0,0,4]
    const headTarget = [0,0,17]
    const metaTarget = [0,0,18]

    let state = 0;  // 0 = head
                    // 1 = meta
                    // 2 = main
                    
    for (let x of buffer) {
        lastbytes.push(x);
        lastbytes.shift();
        
        sections[state].push(x);
        if (compareArrays(lastbytes, headTarget)) state++;
        if (compareArrays(lastbytes, metaTarget)) state++;
        if (compareArrays(lastbytes, mainTarget)) state++;

    }

    const head = parseHead(sections[0])
    const meta = parseMeta(sections[1])
    const main = parseMain(sections[2], head)
    // console.log(head)
    // console.log(meta)
    // console.log(sections[2])
    
}
function parseHead(buffer) {
    buffer.shift();
    buffer.shift();
    const decoder = new TextDecoder();
    let elements = [];

    while (buffer.length > 0) {
        let remaining = buffer.splice(buffer.indexOf(0));
        remaining.shift()
        buffer.shift();
        buffer.pop();
        if (buffer.length > 0) elements.push(decoder.decode(new Buffer.from(buffer)))
        buffer = remaining;
    }

    return elements
}

function parseMeta(buffer) {
    const decoder = new TextDecoder();
    buffer.shift();
    let meta = {
        description: [],
        license: [],
        author: [],
        year: []
    };
    let mode = 0;
    for (let x of buffer) {
        switch (x) {
            case 20:
                mode = "description";
                break;
            case 21:
                mode = "license";
                break;
            case 22:
                mode = "author";
                break;
            case 23:
                mode = "year";
                break;
        }
        meta[mode].push(x)
    }
    for (let x in meta) {
        if (meta[x].length != 0) {
            meta[x].shift();
            meta[x].shift();
            meta[x].pop();
            meta[x].pop();
        }
        if (x != "year") {
            meta[x] = decoder.decode(Buffer.from(meta[x]))
        } else {
            meta[x].pop();
            meta[x].pop();
            meta[x] = byteArrayToInt(meta[x])
        }
    }
    
    return meta
}

function parseMain(buffer, head) {
    console.log(buffer)
}

function grabDatapoints(buffer) {

    const target = [0, 0];
    let lastBytes = [-1, -1]

    let tempArr = [];
    let datapoints = [];


    for (let i in buffer) {
        lastBytes.push(buffer[i]);
        lastBytes.shift();
        tempArr.push(buffer[i]);

        if (compareArrays(target, lastBytes)) {
            datapoints.push(tempArr);
            tempArr = [];
            continue;
        }

    }
    let dp = {}
    for (let x of datapoints) {
        let el = parseDatapoint(x);
        if (el !== null) dp[el.name] = { "t": el.t, "f": el.f }

    }


    return (dp)
}

function parseDatapoint(buffer) {
    let rest = buffer.splice(buffer.indexOf(0));
    let name = buffer;

    const decoder = new TextDecoder();

    // PROCESS NAME
    name.shift();
    let nameT = name.splice(name.indexOf(3))
    let nameStr = "";
    nameStr = decoder.decode(new Uint8Array(name).buffer)

    nameT.shift();
    let nameAmt = 0;
    for (let i in nameT) {
        nameAmt += (Math.pow(256, i) * nameT[i])
    }
    if (nameStr == "") return null;

    // PROCESS REST
    rest.shift();
    rest.pop();
    let tmpRest = [];

    let f = {};

    for (let i of rest) {
        if (i == 0) {
            tmpRest.shift();
            let tmpAmt = tmpRest.splice(tmpRest.indexOf(3));
            let nameArr = new Uint8Array(tmpRest).buffer;
            let tmpName = decoder.decode(nameArr);
            tmpRest = [];
            //console.log("TMP AMT", tmpAmt)
            tmpAmt.shift();
            let amount = 0;
            for (let i in tmpAmt) {
                amount += (Math.pow(256, i) * tmpAmt[i])
            }
            f[tmpName] = amount;
            continue;
        }
        tmpRest.push(i);
    }

    return { "name": nameStr, "t": nameAmt, "f": f }
}


function parseModelWords(buffer) {
    // header starts at byte 3;
    const decoder = new TextDecoder();
    let lastByte = -1;
    let parsetarget = 29;
    let index = 3;
    let tempArr = [];
    let dict = [];

    while (lastByte != parsetarget) {
        if (buffer[index] != 3 && buffer[index] != 2) tempArr.push(buffer[index]);
        if (buffer[index] == 3) {
            dict.push(decoder.decode(new Uint8Array(tempArr).buffer))
            tempArr = [];
        }

        lastByte = buffer[index]
        index++;
    }
    const mainpart = buffer.splice(buffer.indexOf(29) + 1);

    buffer.shift();

    let lastBytes = [-1, -1, -1];
    const target = [0, 0, 0];

    for (let b in buffer) {
        lastBytes.push(buffer[b])
        lastBytes.shift()


        if (compareArrays(lastBytes, target)) {
            // console.log("reached end of main", b);
            buffer.splice(b + 1);
            res = grabDatapointsWord(buffer, dict)
            return res;
        }

    }

    console.log(mainpart)
    console.log(dict, buffer.indexOf(29))
    console.log(index)
}

function grabDatapointsWord(buffer, dict) {
    const target = [0, 0];
    let lastBytes = [-1, -1]

    let tempArr = [];
    let datapoints = [];


    for (let i in buffer) {
        lastBytes.push(buffer[i]);
        lastBytes.shift();
        tempArr.push(buffer[i]);

        if (compareArrays(target, lastBytes)) {
            datapoints.push(tempArr);
            tempArr = [];
            continue;
        }

    }
    let dp = {}
    for (let x of datapoints) {
        let el = parseDatapointWord(x, dict);
        if (el !== null) dp[el.name] = { "t": el.t, "f": el.f }

    }


    return (dp)
}

function parseDatapointWord(dp, dict) {

}

const compareArrays = (a, b) => {
    return a.toString() === b.toString();
}

function intToByteArray(num) {
    if (num < 256) return num;
    num = Math.floor(num);
    let res = [];
    while (num > 0) {
        let y = num % 256;
        res.push(y);
        num -= y;
        num /= 256;
    }
    return res
}

function byteArrayToInt(arr) {
    let res = 0;
    for (let a in arr) {
        res += arr[a] * Math.pow(256, arr.length-a-1);
    }
    return res;
}

class Markov {
    model = {};
    constructor() {
        this.model = { "w": {} };
    }
    description = "";
    license = "";
    author = "";
    year = 0;
    dict = [];

    learn(arr, depth) {
        if (typeof depth !== "number") throw TypeError(`Markov.learn expects learn(string, number), got learn(${typeof arr}, ${typeof depth})`);
        if (typeof arr === "string" && this.model.wordbased === true) throw Error("Cant train word based models with letter based input");
        if (typeof arr === "object" && this.model.wordbased === false) throw Error("Can't train letter based models with word based input");
        this.model.wordbased = (typeof arr === "object")

        let last = new Array(depth).fill(null);

        for (let i = 0; i < arr.length - 1; i++) {
            if(this.model.wordbased) this.dict.push(arr[i])
            last.push(arr[i]);
            last.shift();
            let dpName = last.filter(a => a!=null).join(this.model.wordbased ? " " : "")
            
            let next = arr[i + 1];
            // This will be changed in the future to natively use word lists as a form of compression
            if (this.model.w[dpName] == undefined) {
                this.model.w[dpName] = { t: 1, f: {} }
                this.model.w[dpName].f[next] = 1;
            } else {
                this.model.w[dpName].t++;
                if (this.model.w[dpName].f[next] == undefined) {
                    this.model.w[dpName].f[next] = 1;
                } else {
                    this.model.w[dpName].f[next]++;
                }
            }
        }
        this.dict.push(arr[arr.length-1])
        console.log(`Done learning.. (tokens: ${arr.length}, depth: ${depth})`)
    }

    generate(length, depth, startflag, endflag) {
        if (typeof length !== "number" || typeof depth !== "number") throw TypeError(`Markov.generate expexts generate(number, number), got generate(${typeof length}, ${typeof depth})`)

        let start = startflag || randomProperty(this.model.w);

        let output = start;
        while (output.length < length) {
            let next = getNext(this, output, depth);
            if (next == null) return output;
            if (output.includes(endflag)) return output;
            output += `${this.model.wordbased ? " " : ""}${next}`
        }
        return output
    }

    reset() {
        this.model = { "w": {} }
    }

    // Stringify no longer necessary

    search(str) {
        return this.model.w[str];
    }

    forget(arr, depth, instances) {
        instances = instances || 1;

        if (instances <= 0) throw Error("instances must be at least 1")
        if (typeof depth !== "number") throw TypeError(`Markov.learn expects forget(string, number, number), got forget(${typeof arr}, ${typeof depth},${typeof instances} )`);
        if (typeof arr === "string" && this.model.wordbased === true) throw Error("You must provide an array of words for word based models");
        if (typeof arr === "object" && this.model.wordbased === false) throw Error("You must provide a string for letter based models");

        let last = new Array(depth).fill(null);

        for (let i = 0; i < arr.length - 1; i++) {
            last.push(arr[i]);
            last.shift();
            let dpName = last.join(this.model.wordbased ? " " : "")
            let next = arr[i + 1];

            if (this.model.w[dpName] != undefined) {
                if (this.model.w[dpName].f[next] != undefined) {
                    let totaldelta = Math.min(this.model.w[dpName].f[next], instances);
                    this.model.w[dpName].t -= totaldelta;
                    this.model.w[dpName].f[next] -= totaldelta;
                    if (this.model.w[dpName].f[next] <= 0) delete this.model.w[dpName].f[next];
                    if (Object.keys(this.model.w[dpName].f).length == 0) {
                        delete this.model.w[dpName];
                    }
                }
            }
        }
        console.log(`Done forgetting.. (tokens: ${arr.length}, depth: ${depth}, instances: ${instances})`)

    }

    merge(mergeModel) {
        //Merge this.model with given model
        if (mergeModel.model.wordbased != this.model.wordbased) throw Error("Can't merge letter based models with word based models!");
        if (mergeModel.model.w == undefined) throw Error("Can't merge empty model");
        for (var x in mergeModel.model.w) {
            if (this.model.w[x] == undefined) {
                this.model.w[x] = mergeModel.model.w[x];
            } else {
                this.model.w[x].t += mergeModel.model.w[x].t;
                for (var y in mergeModel.model.w[x].f) {
                    if (this.model.w[x].f[x] == undefined) {
                        this.model.w[x].f[y] = mergeModel.model.w[x].f[y];
                    } else {
                        this.model.w[x].f[y] += mergeModel.model.w[x].f[y];
                    }
                }
            }
        }
        console.log("Done merging!")
    }

    save(filepath) {
        if (!filepath) throw TypeError(`Markov.save expects save(string), got save(${typeof filepath})`);

        const encoder = new TextEncoder();
        
        let temp = []
        temp.push(1);

        if (this.model.wordbased) {
            saveWordBased(filepath, this);
        } else {
            temp.push(14, 25, 29); // letter based model marker, start of head, start of group (synonymous with end of head in this case, header is reserved for dictionaries)
            for (let w in this.model.w) {
                temp.push(2) //start of string
                temp.push(...(encoder.encode(w))) // The string
                temp.push(3); //end of string
                temp.push(...intToByteArray(this.model.w[w].t)) // total number of occurences
                temp.push(0)
                for (let f in this.model.w[w].f) {
                    temp.push(2, encoder.encode(f), 3, ...intToByteArray(this.model.w[w].f[f]), 0)
                }
                temp.push(0) // end of datapoint (double 0)
            }
            temp.push(0) // end of group
            temp.push(29, 4); // End of file (leaving room for easily implementable additional sections)
            // should there some day be more or different data that should be stored,
            // it can be appended between 25 and 4 to maintain backwards compatibility
            // (excess data will simply be ignored)
        }

        let file = new Buffer.from(temp)
        fs.writeFileSync(filepath, file, function () { console.log("Done!") })
    }


    load(filepath) {
        if (!filepath) throw TypeError(`Markov.load expects load(string), got load(${typeof filepath})`);
        // this.model = JSON.parse(this.fs.readFileSync(filepath).toString());
        this.reset();

        let temp = Array.from(fs.readFileSync(filepath));
        console.log(`Loaded ${temp.length} bytes`)
        this.model.wordbased = (temp[0] == 1)

        if (this.model.wordbased) {
            this.model.w = loadWordBased(temp, this)
        } else {
            this.model.w = processAndExtractMainGroup(temp.splice(temp.indexOf(29)));
        }
        console.log("Done!")
    }

}


export { Markov }